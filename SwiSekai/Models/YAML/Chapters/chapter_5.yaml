chapters:
  - chapterName: "Chapter 5: Protocols, Extensions, and Generics"
    modules:
      - id: "C4E2A1B0-3D9F-4B8A-9C7E-5F6A1B2C3D4E"
        module_name: "Protocols"
        module_number: 17
        multiple_choice:
          - question: "What is a protocol?"
            options:
              - "A type of class that cannot be changed."
              - "A blueprint of methods, properties, and other requirements."
              - "A way to organize code into files."
              - "A special kind of function."
            answer: "A blueprint of methods, properties, and other requirements."
          - question: "How does a type indicate that it follows the rules of a protocol?"
            options:
              - "By inheriting from it, like `class Car: Drivable`."
              - "By conforming to it, like `struct Car: Drivable`."
              - "By implementing it, like `struct Car implements Drivable`."
              - "By using the `protocol` keyword in its definition."
            answer: "By conforming to it, like `struct Car: Drivable`."
        content_blocks:
          - type: "heading1"
            content:
              text: "Protocols: Creating Blueprints"
          - type: "explanation"
            content:
              text: "A **protocol** defines a blueprint of methods, properties, and other requirements that are necessary for a particular task or piece of functionality. It doesn't provide the implementation itself; it just describes what is required. Think of it as a contract: any type that signs the contract (conforms to the protocol) agrees to provide the required functionality."
          - type: "heading2"
            content:
              text: "Defining and Conforming to a Protocol"
          - type: "explanation"
            content:
              text: "You define a protocol using the `protocol` keyword. Then, a class, struct, or enum can **conform** to that protocol by listing it after its name, separated by a colon. The type must then provide a concrete implementation for every requirement of the protocol."
          - type: "snippet"
            content:
              code: |
                // 1. Define the blueprint (the contract)
                protocol Drivable {
                    var numberOfWheels: Int { get } // A readable property
                    func startEngine()             // A method
                    mutating func drive()           // A mutating method
                }

                // 2. A struct "signs" the contract
                struct Car: Drivable {
                    let numberOfWheels = 4 // Provide the required property

                    func startEngine() {   // Provide the required method
                        print("Engine started.")
                    }

                    mutating func drive() {      // Provide the required mutating method
                        print("Vroom!")
                    }
                }
          - type: "heading2"
            content:
              text: "Protocols as Types"
          - type: "explanation"
            content:
              text: "Protocols can be used like any other type in Swift. You can create a collection of different types that all conform to the same protocol, allowing you to write flexible, reusable code."
          - type: "snippet"
            content:
              code: |
                func startVehicle(_ vehicle: Drivable) {
                    print("This vehicle has \(vehicle.numberOfWheels) wheels.")
                    vehicle.startEngine()
                }

                let myCar = Car()
                startVehicle(myCar) // We can pass a Car instance to the function

      - id: "B8D7C6A5-4E3F-2A1B-0C9D-8F7E6A5B4C3D"
        module_name: "Protocol Extensions"
        module_number: 18
        multiple_choice:
          - question: "What is a major benefit of using a protocol extension?"
            options:
              - "It makes the original protocol smaller."
              - "It allows you to provide default implementations for protocol requirements."
              - "It is the only way to add new methods to a protocol."
              - "It forces all conforming types to be classes."
            answer: "It allows you to provide default implementations for protocol requirements."
          - question: "If a conforming type provides its own implementation of a method that is also in a protocol extension, which one is used?"
            options:
              - "The protocol extension's implementation is always used."
              - "The code will not compile."
              - "The conforming type's own implementation is used."
              - "It depends on whether it's a struct or a class."
            answer: "The conforming type's own implementation is used."
        content_blocks:
          - type: "heading1"
            content:
              text: "Extensions: Adding Functionality"
          - type: "explanation"
            content:
              text: "**Extensions** allow you to add new functionality to an existing class, structure, enumeration, or protocol type. This includes the ability to add new computed properties and methods, even for types you didn't write yourself (like `Int` or `String`)."
          - type: "heading2"
            content:
              text: "Extending a Protocol"
          - type: "explanation"
            content:
              text: "One of the most powerful features in Swift is the ability to extend a protocol. This lets you provide **default implementations** for methods and computed properties. Any type that conforms to the protocol will get this behavior for free, without having to write any code itself."
          - type: "snippet"
            content:
              code: |
                protocol Describable {
                    func describe() -> String
                }

                // We extend the protocol to provide a default way to describe something
                extension Describable {
                    func describe() -> String {
                        return "This is a default description."
                    }
                }

                // This struct conforms, but doesn't need to implement describe()
                // It gets the default implementation for free.
                struct Item: Describable { }
                let item = Item()
                print(item.describe()) // Prints "This is a default description."

                // This struct CONFORMS and provides its OWN implementation.
                // Its own version will be used instead of the default.
                struct Person: Describable {
                    var name: String
                    func describe() -> String {
                        return "This person's name is \(name)."
                    }
                }
                let person = Person(name: "Alex")
                print(person.describe()) // Prints "This person's name is Alex."

      - id: "A2B3C4D5-6E7F-8A9B-0C1D-2E3F4A5B6C7D"
        module_name: "Introduction to Generics"
        module_number: 19
        multiple_choice:
          - question: "What is the primary purpose of generics?"
            options:
              - "To generate code automatically."
              - "To make code faster."
              - "To write flexible, reusable functions and types that can work with any type."
              - "To simplify the syntax of Swift."
            answer: "To write flexible, reusable functions and types that can work with any type."
          - question: "In `func doSomething<T>(item: T)`, what does `T` represent?"
            options:
              - "A specific type called 'T'."
              - "A placeholder for any type, determined when the function is called."
              - "A shorthand for 'Text'."
              - "An error in the code."
            answer: "A placeholder for any type, determined when the function is called."
        content_blocks:
          - type: "heading1"
            content:
              text: "Introduction to Generics"
          - type: "explanation"
            content:
              text: "**Generic code** enables you to write flexible, reusable functions and types that can work with any type, subject to requirements that you define. You can write code that avoids duplication and expresses its intent in a clear, abstracted way. Swift's `Array` and `Dictionary` are generic collections."
          - type: "heading2"
            content:
              text: "The Problem Generics Solve"
          - type: "explanation"
            content:
              text: "Imagine you need a function to swap two `Int` values, and another to swap two `String` values. The code would be identical except for the data type. Generics let you write a single function that can swap values of *any* type."
          - type: "snippet"
            content:
              code: |
                // Non-generic functions (duplication of code)
                func swapTwoInts(_ a: inout Int, _ b: inout Int) {
                    let tempA = a
                    a = b
                    b = tempA
                }
                func swapTwoStrings(_ a: inout String, _ b: inout String) {
                    let tempA = a
                    a = b
                    b = tempA
                }
          - type: "heading2"
            content:
              text: "Generic Functions"
          - type: "explanation"
            content:
              text: "A generic function uses a **placeholder type name** (traditionally a capital letter like `T`, `U`, or `V`) instead of an actual type name. The actual type is determined when the function is called."
          - type: "snippet"
            content:
              code: |
                // A single generic function that works for ANY type
                func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
                    let tempA = a
                    a = b
                    b = tempA
                }

                var score1 = 100
                var score2 = 200
                swapTwoValues(&score1, &score2) // T is inferred to be Int
                // score1 is now 200, score2 is now 100

                var name1 = "Alex"
                var name2 = "Maria"
                swapTwoValues(&name1, &name2) // T is inferred to be String
                // name1 is now "Maria", name2 is now "Alex"

    finalReview:
      content_blocks:
        - type: "heading1"
          content:
            text: "Chapter 5 Review"
        - type: "explanation"
          content:
            text: "You've reached a major milestone! This chapter introduced some of the most advanced and powerful abstraction tools in Swift. These concepts are what enable developers to build large, maintainable, and flexible applications."
        - type: "heading2"
          content:
            text: "Key Concepts You've Mastered"
        - type: "explanation"
          content:
            text: "**Protocols (`protocol`):** You now know how to define a 'contract' or 'blueprint' of functionality. This allows you to write code that works with any type, as long as that type promises to provide the required behavior."
        - type: "explanation"
          content:
            text: "**Extensions (`extension`):** You can add new functionality to existing types, including providing default implementations for protocol methods. This makes your code more reusable and reduces boilerplate."
        - type: "explanation"
          content:
            text: "**Generics (`<T>`):** You have the power to write truly flexible code. By using placeholder types, you can create functions and data types (like Swift's Array) that work with any type, eliminating code duplication."
