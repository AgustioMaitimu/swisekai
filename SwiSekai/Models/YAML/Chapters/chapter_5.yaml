chapters:
  - chapterName: "Chapter 5: The Universal Laws"
    modules:
      - id: "C4E2A1B0-3D9F-4B8A-9C7E-5F6A1B2C3D4E"
        module_name: "Contracts of Capability: Protocols"
        module_number: 23
        multiple_choice:
          - question: "What is a Protocol?"
            options:
              - "A type of Automaton that cannot be changed."
              - "A blueprint of required capabilities, like a contract."
              - "A method of organizing your project files."
              - "A special kind of function."
            answer: "A blueprint of required capabilities, like a contract."
        content_blocks:
          - type: "heading1"
            content:
              text: "Protocols: The Laws of Behavior"
          - type: "explanation"
            content:
              text: "You have become a skilled architect. It is time to learn the Universal Laws that govern all of SwiftCraft. A **protocol** is one such law. It is a contract that defines a set of capabilities. It doesn't provide the implementation, it only states the requirements. Any blueprint—`struct` or `class`—that agrees to the contract must provide the required functionality."
          - type: "heading2"
            content:
              text: "Defining and Adopting a Protocol"
          - type: "explanation"
            content:
              text: "You define the contract with the `protocol` keyword. A blueprint then **conforms** to it by listing the protocol's name after its own. It is now bound by that contract and must implement every capability the protocol demands."
          - type: "snippet"
            content:
              code: |
                // 1. Define the contract. Anything 'Identifiable' MUST have an 'id'.
                protocol Identifiable {
                    var id: String { get } // Must have a readable 'id' property of type String
                    func identify()        // Must have an 'identify' method
                }
                // 2. A struct adopts the contract.
                struct User: Identifiable {
                    var id: String
                    var name: String
                    func identify() {
                        print("My ID is \\(id) and my name is \\(name).")
                    }
                }
                let user = User(id: "u-123", name: "Alex")
                user.identify()
          - type: "heading2"
            content:
              text: "Protocols as a Universal Type"
          - type: "explanation"
            content:
              text: "This is the true power of protocols. You can write functions that accept any object, no matter if it's a `struct` or a `class`, as long as it conforms to a specific protocol. This allows you to write incredibly flexible and reusable code."

      - id: "B8D7C6A5-4E3F-4A1B-8C9D-8F7E6A5B4C3D"
        module_name: "Universal Enchantments: Extensions"
        module_number: 24
        multiple_choice:
          - question: "What is a primary benefit of using a Protocol Extension?"
            options:
              - "It reduces the size of the original Protocol."
              - "It allows you to provide a default implementation for a Protocol's requirements."
              - "It is the only way to add new capabilities to a Protocol."
              - "It forces all conforming types to be Classes."
            answer: "It allows you to provide a default implementation for a Protocol's requirements."
        content_blocks:
          - type: "heading1"
            content:
              text: "Extensions: Augmenting Existing Blueprints"
          - type: "explanation"
            content:
              text: "**Extensions** are a form of high magic. They allow you to add new capabilities (methods, computed properties) to any existing blueprint, even the core elements of the realm like `Int` and `String` that you did not forge yourself."
          - type: "heading2"
            content:
              text: "Extending a Protocol"
          - type: "explanation"
            content:
              text: "One of the most profound arts is extending a protocol itself. This allows you to provide a **default implementation** for a capability. Any type that adopts the contract gets this default behavior for free, as if by a universal enchantment. This is a powerful way to reduce code repetition."
          - type: "snippet"
            content:
              code: |
                protocol Describable {
                    func describe() -> String
                }
                // We cast a universal enchantment on the 'Describable' contract.
                extension Describable {
                    // This is now the default way to 'describe'.
                    func describe() -> String {
                        return "This is a standard object."
                    }
                }
                // This struct adopts the contract but doesn't need to provide an
                // implementation for 'describe'. It gets the default one for free.
                struct Rock: Describable {}
                let rock = Rock()
                print(rock.describe()) // Prints "This is a standard object."

      - id: "A2B3C4D5-6E7F-4A9B-8C1D-2E3F4A5B6C7D"
        module_name: "The Art of Metamagic: Generics"
        module_number: 25
        multiple_choice:
          - question: "What is the primary purpose of Generics?"
            options:
              - "To generate code automatically."
              - "To make creations faster."
              - "To write flexible, reusable blueprints that can work with any element type."
              - "To simplify the syntax of SwiftCraft."
            answer: "To write flexible, reusable blueprints that can work with any element type."
        content_blocks:
          - type: "heading1"
            content:
              text: "Generics: The Highest Form of Abstraction"
          - type: "explanation"
            content:
              text: "**Generic code** is the art of Metamagic. It enables you to write blueprints for mechanisms and constructs that are so abstract, they can work with any element type. It is the ultimate expression of 'Don't Repeat Yourself'. The `Array` and `Dictionary` you've been using are themselves masterworks of generic design."
          - type: "heading2"
            content:
              text: "The Problem Metamagic Solves"
          - type: "explanation"
            content:
              text: "Imagine you need a mechanism to check if two `Int`s are equal, and another to check if two `String`s are equal. The logic is identical. Metamagic lets you create a single mechanism that works for any type that can be compared for equality."
          - type: "heading2"
            content:
              text: "Generic Functions"
          - type: "explanation"
            content:
              text: "A generic function uses a **placeholder type name** (traditionally a capital letter like `T` in angle brackets `<>`) instead of a concrete type like `Int`. The actual type is determined when the function is called."
          - type: "snippet"
            content:
              code: |
                // This function can take an array of ANY type of element.
                // It prints the first item, if it exists.
                func printFirst<T>(in array: [T]) {
                    if let firstItem = array.first {
                        print("The first item is: \\(firstItem)")
                    } else {
                        print("The array is empty.")
                    }
                }
                let numbers = [10, 20, 30]
                let names = ["A", "B", "C"]
                printFirst(in: numbers) // T is inferred to be Int. Prints "The first item is: 10"
                printFirst(in: names)   // T is inferred to be String. Prints "The first item is: A"

    finalReview:
      content_blocks:
        - type: "heading1"
          content:
            text: "Chapter 5 Review: The Master Architect"
        - type: "explanation"
          content:
            text: "Your journey as an apprentice is complete. You have studied not just how to build, but the very laws that govern creation in SwiftCraft. You are now ready to design and build magnificent creations of your own. The path of learning is endless, but you are now a Master Architect."
        - type: "heading2"
          content:
            text: "Arts You Have Mastered"
        - type: "explanation"
          content:
            text: "**Protocols (`protocol`):** You can now define Contracts of Capability, writing flexible code that works with any type that conforms to the law."
        - type: "explanation"
          content:
            text: "**Extensions (`extension`):** You can cast Universal Enchantments, adding new functionality to existing blueprints and providing default behaviors for your protocols."
        - type: "explanation"
          content:
            text: "**Generics (`<T>`):** You can wield the Art of Metamagic, creating supremely reusable and abstract blueprints that work with any element type, representing the pinnacle of architectural elegance."
