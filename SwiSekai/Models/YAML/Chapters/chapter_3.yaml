chapters:
  - chapterName: "Chapter 3: Designing Mechanisms"
    modules:
      - id: "A5B4C3D2-E1F0-4D9C-B8A7-9E8D7C6B5A49"
        module_name: "Reusable Mechanisms: Functions"
        module_number: 14
        multiple_choice:
          - question: "What is the primary benefit of creating a Function?"
            options:
              - "To make your commands execute faster."
              - "To package a reusable sequence of commands and avoid repetition."
              - "To store large amounts of data."
              - "To create new types of elements."
            answer: "To package a reusable sequence of commands and avoid repetition."
        content_blocks:
          - type: "heading1"
            content:
              text: "Crafting Reusable Code with Functions"
          - type: "explanation"
            content:
              text: "A Master Architect doesn't rebuild the same staircase for every floor. They create a single, perfect blueprint for 'staircase' and reuse it. A **Function** is exactly that: a named, reusable mechanism of commands. You build it once, and then you can call upon it anytime, anywhere."
          - type: "heading2"
            content:
              text: "Defining and Calling a Function"
          - type: "explanation"
            content:
              text: "You define the mechanism using the `func` keyword. To activate it, you **call** it by its name."
          - type: "snippet"
            content:
              code: |
                // Define the function (the blueprint for the mechanism)
                func igniteCampfire() {
                    print("The logs crackle to life.")
                    print("The fire is lit. You are safe for now.")
                }
                // Call the function to activate the mechanism
                igniteCampfire()
          - type: "heading2"
            content:
              text: "Providing Inputs (Parameters)"
          - type: "explanation"
            content:
              text: "Your mechanisms become far more versatile if you can give them different inputs each time. These inputs are called **parameters**."
          - type: "snippet"
            content:
              code: |
                // 'recipient' is a parameter of type String
                func sendRaven(to recipient: String) {
                    print("A raven is sent to \\(recipient)...")
                }
                sendRaven(to: "Winterfell")
                sendRaven(to: "The Citadel")
          - type: "heading2"
            content:
              text: "Producing an Output (Return Values)"
          - type: "explanation"
            content:
              text: "Some mechanisms don't just perform an action; they produce a result. This is a **return value**. You specify the type of element it will return using an arrow `->`."
          - type: "snippet"
            content:
              code: |
                // This function promises to return an Int
                func rollDice() -> Int {
                    // A simple dice roll from 1 to 6
                    return Int.random(in: 1...6)
                }
                let diceRollResult = rollDice()
                print("You rolled a \\(diceRollResult).")

      - id: "B6A5B4C3-D2E1-4F0A-B9B8-A7E6D5C4B3A2"
        module_name: "Peering into the Void: Optionals"
        module_number: 15
        multiple_choice:
          - question: "In SwiftCraft, what does `nil` represent?"
            options:
              - "The number zero."
              - "An empty text."
              - "The absence of a value; the Void."
              - "A flawed command."
            answer: "The absence of a value; the Void."
        content_blocks:
          - type: "heading1"
            content:
              text: "Handling Uncertainty with Optionals"
          - type: "explanation"
            content:
              text: "What happens when you search for a treasure that isn't there? In lesser realms, this could cause your entire creation to crumble. SwiftCraft handles this with a profound concept: **Optionals**. An Optional is an enchanted container that acknowledges uncertainty. It says, 'I might contain a treasure, or I might contain nothing but the Void.'"
          - type: "heading2"
            content:
              text: "The Concept of `nil`"
          - type: "explanation"
            content:
              text: "The state of 'nothing' is represented by the special value `nil`. It is the Voidâ€”the confirmed absence of a value."
          - type: "heading2"
            content:
              text: "Declaring Optionals"
          - type: "explanation"
            content:
              text: "You declare a container as an Optional by adding a question mark `?` to its type. This is your way of telling SwiftCraft, 'I understand this container might be empty, and I will handle it with care.' A non-optional container is guaranteed to *never* be empty."
          - type: "snippet"
            content:
              code: |
                // A standard container for a hero's name. It CANNOT be nil.
                let heroName: String = "Gideon"
                // An optional container for a pet's name. A hero might not have a pet.
                var petName: String? = "Shadow"
                petName = nil // The pet ran away. This is now valid.

      - id: "C7B6A5B4-C3D2-4E1F-A0B9-B8A7E6D5C4B3"
        module_name: "Binding the Void: Unwrapping"
        module_number: 16
        multiple_choice:
          - question: "What is the safest ritual for retrieving a value from an Optional?"
            options:
              - "Forceful Dispelling with `!`"
              - "The Void-Coalescing Operator `??`"
              - "Void Binding with `if let`"
              - "All rituals are equally safe."
            answer: "Void Binding with `if let`"
        content_blocks:
          - type: "heading1"
            content:
              text: "Safely Handling Optionals: Unwrapping"
          - type: "explanation"
            content:
              text: "Because an Optional might contain `nil`, SwiftCraft protects you from using it directly. You must first perform a ritual to safely check its contents and extract the value. This is called **unwrapping**."
          - type: "heading2"
            content:
              text: "Void Binding (`if let`)"
          - type: "explanation"
            content:
              text: "This is the most revered and safest ritual. `if let` peers into the Optional. If it finds a value, it binds it to a temporary, non-optional container and executes your code. If it finds only the `nil` void, it simply skips your code."
          - type: "snippet"
            content:
              code: |
                var treasureFound: String? = "Amulet of Power"
                // treasureFound = nil // Uncomment this line to see the 'else' path activate
                if let treasure = treasureFound {
                    // This code only runs if a treasure was actually found
                    print("You found the \\(treasure)!")
                } else {
                    // This code runs only if treasureFound was nil
                    print("The chest is empty.")
                }
          - type: "heading2"
            content:
              text: "Void-Coalescing Operator (`??`)"
          - type: "explanation"
            content:
              text: "This elegant command provides a **default value** to use if the Optional is empty. The command `a ?? b` means 'try to unwrap `a`; if you can't, use `b` instead'."
          - type: "snippet"
            content:
              code: |
                let customPlayerTitle: String? = nil
                // If customPlayerTitle is nil, use "Adventurer" as the default.
                let displayTitle = customPlayerTitle ?? "Adventurer"
                print("Welcome, \\(displayTitle).") // Prints "Welcome, Adventurer."
          - type: "heading2"
            content:
              text: "Forceful Dispelling (`!`)"
          - type: "explanation"
            content:
              text: "You can forcefully tear the value from an Optional with `!`. **This is dangerous and rarely advised.** It is a promise to the realm of SwiftCraft that you are 100% certain a value exists. If you are wrong, and it contains `nil`, your entire creation will shatter (the app will crash)."

      - id: "D8C7B6A5-B4C3-4D2E-B1F0-A9B8A7E6D5C4"
        module_name: "Custom Blueprints: Structures"
        module_number: 17
        multiple_choice:
          - question: "What is the keyword used to define a custom blueprint?"
            options:
              - "struct"
              - "structure"
              - "type"
              - "class"
            answer: "struct"
        content_blocks:
          - type: "heading1"
            content:
              text: "Structures: Designing Your Own Components"
          - type: "explanation"
            content:
              text: "You are no longer limited to the core elements. You can now design your own blueprints for custom components. The most common way is with a **Structure**, or `struct`. A `struct` is a blueprint that groups related elements together to represent a single, meaningful concept."
          - type: "heading2"
            content:
              text: "Designing and Forging a Struct"
          - type: "explanation"
            content:
              text: "Imagine you're building a world. You need to represent a Hero. A hero has a name, a class, and a level. A `struct` is the perfect blueprint for this. You define the blueprint, and then you can forge an **instance** (a real, living hero) from it."
          - type: "snippet"
            content:
              code: |
                // 1. Design the blueprint for a Hero component
                struct Hero {
                    var name: String
                    var heroClass: String
                    var level: Int
                }
                // 2. Forge a real instance from the blueprint
                // SwiftCraft provides a basic forging command automatically.
                let arion = Hero(name: "Arion", heroClass: "Warrior", level: 10)
                // 3. Access the properties of your creation with dot syntax
                print("\\(arion.name) is a level \\(arion.level) \\(arion.heroClass).")

    finalReview:
      content_blocks:
        - type: "heading1"
          content:
            text: "Chapter 3 Review: The Mechanism Designer"
        - type: "explanation"
          content:
            text: "You have made a great leap, Apprentice. You have learned the arts of a true designer, capable of crafting reusable mechanisms and handling the uncertainties of creation."
        - type: "heading2"
          content:
            text: "Arts You Have Mastered"
        - type: "explanation"
          content:
            text: "**Functions (`func`):** You can now craft reusable mechanisms, providing inputs with **parameters** and receiving outputs with **return values**."
        - type: "explanation"
          content:
            text: "**Optionals (`?`):** You understand how SwiftCraft safely handles the Void (`nil`) by wrapping it in a protective container."
        - type: "explanation"
          content:
            text: "**Unwrapping:** You have mastered the safe rituals for handling Optionals, using **Void Binding** (`if let`) to check for a value and the **Void-Coalescing Operator** (`??`) to provide a default."
        - type: "explanation"
          content:
            text: "**Structures (`struct`):** You can now design your own custom blueprints, grouping related elements into a single, logical component."
