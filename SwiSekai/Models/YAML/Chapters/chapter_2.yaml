chapters:
  - chapterName: "Chapter 2: Collection Types and Control Flow"
    modules:
      - id: "E0653B81-CC42-40F8-8AE1-4A6A9858461D"
        module_name: "Collections: Arrays"
        module_number: 8
        multiple_choice:
          - question: "How do you access the first element in an array named `colors`?"
            options:
              - "colors.first"
              - "colors[1]"
              - "colors[0]"
              - "colors.get(0)"
            answer: "colors[0]"
          - question: "What method is used to add a new element to the end of an array?"
            options:
              - ".add()"
              - ".insert()"
              - ".push()"
              - ".append()"
            answer: ".append()"
          - question: "If `let numbers = [10, 20, 30]`, what is the value of `numbers.count`?"
            options:
              - "2"
              - "3"
              - "30"
              - "The code will error."
            answer: "3"
        content_blocks:
          - type: "heading1"
            content:
              text: "Collections: Arrays"
          - type: "explanation"
            content:
              text: "An **Array** is an ordered collection that stores multiple values of the same type. Think of it as a numbered list of items. The order you put them in is the order they stay in."
          - type: "heading2"
            content:
              text: "Creating and Typing Arrays"
          - type: "explanation"
            content:
              text: "You create an array by putting values in square brackets `[]`, separated by commas. Swift can often infer the type, but you can be explicit by writing the type in brackets, like `[String]` or `[Int]`."
          - type: "snippet"
            content:
              code: |
                // Swift infers this is an array of Strings: [String]
                let team_members = ["Zoe", "Leo", "Ava"]

                // Creating an empty array requires an explicit type
                var scores: [Int] = []
          - type: "heading2"
            content:
              text: "Accessing and Modifying Arrays"
          - type: "explanation"
            content:
              text: "You access elements by their position, or **index**, which starts at **0**. You can use common properties and methods like `.count` to get the number of items, `.append()` to add an item to the end, and `.remove(at:)` to remove an item at a specific index."
          - type: "snippet"
            content:
              code: |
                var planets = ["Mercury", "Venus", "Earth"]

                // Access the first planet (index 0)
                let first_planet = planets[0] // "Mercury"

                // Add a new planet to the end
                planets.append("Mars")

                // Remove Venus (at index 1)
                planets.remove(at: 1)

                print("There are \(planets.count) planets.") // Prints "There are 3 planets."

      - id: "4AB37D43-A27C-453F-B632-A04B66868355"
        module_name: "Collections: Dictionaries"
        module_number: 9
        multiple_choice:
          - question: "Which of the following correctly defines a dictionary?"
            options:
              - "An ordered list of values."
              - "An unordered collection of key-value pairs."
              - "A collection that can only store Strings."
              - "A fixed-size list of items."
            answer: "An unordered collection of key-value pairs."
          - question: "How would you get the value associated with the key `\"age\"` from a dictionary named `user`?"
            options:
              - "user.get(\"age\")"
              - "user[0]"
              - "user[\"age\"]"
              - "user.age"
            answer: "user[\"age\"]"
        content_blocks:
          - type: "heading1"
            content:
              text: "Collections: Dictionaries"
          - type: "explanation"
            content:
              text: "A **Dictionary** is an unordered collection that stores associations between **keys** and **values**. Each value is linked to a unique key, just like how a word in a real dictionary is linked to its definition. Keys must be unique."
          - type: "heading2"
            content:
              text: "Creating Dictionaries"
          - type: "explanation"
            content:
              text: "You create dictionaries using square brackets, with a colon separating each key and its value. The type of a dictionary is written as `[KeyType: ValueType]`."
          - type: "snippet"
            content:
              code: |
                // A dictionary mapping String keys to Int values
                var populations: [String: Int] = [
                    "Tokyo": 37_000_000,
                    "Delhi": 32_000_000,
                    "Shanghai": 28_000_000
                ]
          - type: "heading2"
            content:
              text: "Accessing and Modifying Dictionaries"
          - type: "explanation"
            content:
              text: "You use the key to access, change, or add values. If you try to access a key that doesn't exist, you'll get back `nil`, which means 'no value'."
          - type: "snippet"
            content:
              code: |
                // Accessing the population of Tokyo
                let tokyo_pop = populations["Tokyo"] // 37_000_000

                // Adding a new key-value pair
                populations["Cairo"] = 22_000_000

                // Updating an existing value
                populations["Shanghai"] = 29_000_000

                // Removing a pair by setting its value to nil
                populations["Delhi"] = nil

      - id: "2ACFC5F6-14BA-4676-BE6F-DA150139E326"
        module_name: "Making Decisions: Conditionals"
        module_number: 10
        multiple_choice:
          - question: "Which operator checks for equality between two values?"
            options:
              - "="
              - "=="
              - "!="
              - "&&"
            answer: "=="
          - question: "What will this code print?\nlet temperature = 30\nif temperature > 25 { print(\"It's hot.\") } else { print(\"It's not hot.\") }"
            options:
              - "It's hot."
              - "It's not hot."
              - "It will print both."
              - "It will print nothing."
            answer: "It's hot."
          - question: "Which operator represents a logical AND?"
            options:
              - "OR"
              - "||"
              - "AND"
              - "&&"
            answer: "&&"
        content_blocks:
          - type: "heading1"
            content:
              text: "Making Decisions: Conditionals"
          - type: "explanation"
            content:
              text: "So far, our code runs from top to bottom. But what if we want to run code only if a certain condition is true? That's where **conditionals** come in. They allow your program to make decisions and follow different paths."
          - type: "heading2"
            content:
              text: "The `if` Statement"
          - type: "explanation"
            content:
              text: "The `if` statement checks a condition. If the condition is `true`, a block of code runs. If it's `false`, the block is skipped. We use **comparison operators** like `>` (greater than), `<` (less than), and `==` (equal to) to form the conditions."
          - type: "snippet"
            content:
              code: |
                let user_age = 18
                if user_age >= 18 {
                    print("You are eligible to vote.")
                }
          - type: "heading2"
            content:
              text: "`else` and `else if`"
          - type: "explanation"
            content:
              text: "You can provide an alternative path for when the condition is `false` using an `else` block. For more complex choices, you can chain multiple checks together with `else if`."
          - type: "snippet"
            content:
              code: |
                let score = 85
                if score >= 90 {
                    print("Grade: A")
                } else if score >= 80 {
                    print("Grade: B")
                } else {
                    print("Grade: C or below")
                }
                // Prints "Grade: B"

      - id: "13679815-F4BB-4DE9-903A-3F02C75D2536"
        module_name: "More Control Flow: Switch Statements"
        module_number: 11
        multiple_choice:
          - question: "What is the purpose of the `default` case in a switch statement?"
            options:
              - "It's the first case that runs."
              - "It's optional and rarely used."
              - "It runs if no other case matches the value."
              - "It sets the default value for the variable."
            answer: "It runs if no other case matches the value."
          - question: "Which feature is unique to Swift's switch statements compared to many other languages?"
            options:
              - "They only work with numbers."
              - "They must be exhaustive (cover all possible values)."
              - "They do not need a `default` case."
              - "They cannot match against ranges."
            answer: "They must be exhaustive (cover all possible values)."
        content_blocks:
          - type: "heading1"
            content:
              text: "More Control Flow: Switch Statements"
          - type: "explanation"
            content:
              text: "A **`switch`** statement is another way to control your program's flow. It's often cleaner and more powerful than a long `if-else if` chain, especially when you are checking a single value against many possible conditions."
          - type: "heading2"
            content:
              text: "Basic Syntax"
          - type: "explanation"
            content:
              text: "You provide a value to `switch` on, and then define several `case`s that the value might match. Swift checks them in order. A powerful feature of Swift is that `switch` statements must be **exhaustive**, meaning you must provide a `case` for every possible value, or include a `default` case to handle anything not explicitly listed."
          - type: "snippet"
            content:
              code: |
                let http_status_code = 404

                switch http_status_code {
                case 200:
                    print("OK")
                case 404:
                    print("Not Found")
                case 500:
                    print("Internal Server Error")
                default:
                    print("Unknown status code")
                }
                // Prints "Not Found"
          - type: "heading2"
            content:
              text: "Matching Ranges"
          - type: "explanation"
            content:
              text: "You're not limited to matching single values. You can also match against number ranges, which makes `switch` incredibly versatile."
          - type: "snippet"
            content:
              code: |
                let year = 2025
                switch year {
                case ..<2000:
                    print("In the 20th Century")
                case 2000...2024:
                    print("In the early 21st Century")
                default:
                    print("The present or the future")
                }
                // Prints "The present or the future"

    finalReview:
      content_blocks:
        - type: "heading1"
          content:
            text: "Chapter 2 Review"
        - type: "explanation"
          content:
            text: "Fantastic progress! You've moved beyond single values and now have the tools to manage collections of data and control the logical flow of your programs."
        - type: "heading2"
          content:
            text: "Key Concepts You've Mastered"
        - type: "explanation"
          content:
            text: "**Arrays:** You know how to create and manage ordered lists of data. You can access elements by their index (starting at 0) and modify the list with methods like `.append()` and `.remove(at:)`."
        - type: "explanation"
          content:
            text: "**Dictionaries:** You learned how to store data as key-value pairs, perfect for when you need to look up a value without knowing its position. Remember that they are unordered!"
        - type: "explanation"
          content:
            text: "**`if`, `else if`, `else`:** You can now write code that makes decisions. By checking conditions with comparison operators (`==`, `>`, `!=`, etc.), you can direct your program to execute different blocks of code."
        - type: "explanation"
          content:
            text: "**`switch` Statements:** You have a powerful and clean alternative to `if` statements for checking a single value against multiple possible conditions, including ranges. You also learned that they must be exhaustive."
